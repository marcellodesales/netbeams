\chapter{Appendix}

This section includes the source-code for the DSP Data Persistence. Each
section details one single main artifact used on the development of the
component. However, only the main ones will be added into this document, while
the remainder can be downloaded directly from the Subversion repository.

\section{The Data Sensor Platform (DSP)}
\label{sec:dsp-details}

The Data Sensor Platform, in short DSP Platform, is based on a micro-kernel
architecture developed on top of the Java modular framework called OSGi
\cite{osgi}. The platform represents the foundation of the execution of
NetBEAMS, since it is executed from an embedded hardware called Gumstix
\cite{gumstix} using a Linux operating system and on top of the Java Virtual
Machine (JVM). In order to transport data from sensors hosts to the network
sink, the use of a cellular connection is used to transport the collected data
from the senso devices using the HTTP Protocol, as described by
\citet{netbeams2009}. Figure \ref{fig:sf-netbeams-node} shows the
architecture of the inhanced node designed by the NetBEAMS research group.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.5]{../diagrams/DSP-Gateway-Node}
  \caption{The NetBEAMS Node enhancement with the Gumstix and the GSM Modem}
  \label{fig:sf-netbeams-node}
\end{figure}

The following list describes each of the devices in the NetBEAMS Node.

\begin{itemize}
  \item \textbf{YSI 6600EDS V2}: the YSI device is the regular sonde
  responsible for observing the environment. It is connected to the Gumstix
  embedded system, where the DSP is executed;
  \item \textbf{Gumstix console-vx}: it's a COTS ARM-based hardware that
  provides a computer-on-module environment for the development of small
  embedded systems. This is the main environment of data extraction and remote
  processing is accomplished. It runs a cross-compiled version of Linux Kernel
  2.6;
  \item \textbf{Huawei E220 USB Modem}: it is used to transfer the data from the
  Gumstix to the RTC Labs Data Center.
\end{itemize} 

The DSP runs inside of the embedded system Gumstix. The following sections
details its design and process for extracting data.

\subsection{The DSP System Design}

This section focus on the development of a Software Platform for the NetBEAMS
Gateway Embedded System, or on the system developed in the Gumstix device. As
shown in figure \ref{fig:netbeams-software-stack}, the NetBEAMS Gateway Node is
an embedded system that contains a set of layer found in any computer.
However, each of the resources described from the system were customized for
the NetBEAMS system. The main components of such system can be summarized as
follows:

\begin{itemize}
  \item \textbf{Operating System}: it uses a cross-compiled Gentoo Linux, which
  supports a wide variety of development tools, including the Java Virtual Machine
  (JVM), the underlying platform system;
  \item \textbf{Java Virtual Machine}: it uses the JamVM, a ~200 KB version of
  the Sun Microsystems Java Virtual Machine, version 2.0;
  \item \textbf{OSGi Framework}: it uses the Knopflerfish implementation of the
  OSGi 4.1 specification. More details in the following sections.
  \item \textbf{DSP Platform and other Bundles}: The plug-and-play DSP
  Components are based on the OSGi bundles capabilities, which can reuse services registered in the OSGi framework.
\end{itemize}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.6]{../diagrams/NetBEAMS-Client-Node-Components}
  \caption{The NetBEAMS's Gumstix Software Stack}
  \label{fig:netbeams-software-stack}
\end{figure}

As depicted in figure \ref{fig:netbeams-software-stack}, the DSP Sonde Data
Producer component opens a serial connection with the device through the Java
Native Interface (JNI) driver and produces the data flow 1. The data stream
format at this stage is as described on table \ref{tab:ysi-data-stream}.
Later, by parsing and transforming the data to DSP internal representation, it
sends the data to the DSP Platform as depicted on flow 2. Finally, the DSP
Platform decides to send the data to the DSP Wire Transport Client, as shown
on flow 3, by following rules defined by the system administrator. At this
point, the data is ready to be transmitted to the server, which is covered on
the following sections.

\subsection{The DSP Platform Architecture}
\label{netbeams-architecture}

The architecture of the DSP, aligned with the OSGi capabilities, reuses the
Service-Oriented Architecture that can easily enable and disable plug-and-play
components. By following a publish-subscriber design-pattern \cite{gof}, the
service producer registers into the service broker while the consumer looks
for a given registered service in the Service Broker. For this reason, this
approach allows decoupled interoperability among modules as it is shown in
figure \ref{fig:publish-subscriber-pattern}.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.6]{../diagrams/publish-subscriber-pattern}
  \caption{The publish-subscriber design-pattern for services}
  \label{fig:publish-subscriber-pattern}
\end{figure}

The DSP infrastructure is based on a loosely-coupled architecture hosted in a
given host computer with an OSGi container, where the entire system is
composed by a set of plug-n-play OSGi modules. Each DSP component, as an
instance of an OSGi Module, can perform specialized tasks according to its
specification. In general, each DSP component can be categorized as follows:

\begin{itemize}
  \item \textbf{Data Producer (DP)}, whose main function is to produce data for
  the system;
  \item \textbf{Data Consumer (DC)}, whose main function is to consume the
  received data.
\end{itemize}

\begin{figure}[!b]
  \centering
  \includegraphics[scale=0.7]{../diagrams/DSP-Producers-Consumers-Components-Interactions}
  \caption{The basic architecture of a Data Sensor Platform (DSP)}
  \label{fig:DSP-Producers-Consumers-Components-Interactions}
\end{figure}

The Data Producers and Data Consumers exchange data through the DSP Message
Broker using a message unit called DSP Message. As it is depicted in figure
\ref{fig:DSP-Producers-Consumers-Components-Interactions}, a Data Producer
creates a set of one or more DSP Messages wrapped up in a DSP
MessagesContainer in order to be sent to the DSP Message Broker. When the
broker receives the set of DSP Messages, it requests a list of Data Consumers
to each of the DSP Messages based on rules managed by the DSP Matcher.
Whenever the broker acquires the list of Data Consumers, it delivers a copy of
the DSP Message to each of the Data Consumers in the receiving list. Upon the
DSP Message arrival, each Data Consumer can extract the actual data from the
DSPMessage. Finally, although the components can be distinguished between Data
Producers and Consumers, any of them are entitled to send and receive
administrative DSP Messages, which is covered in the following sections.

When the DSP Platform is installed into the OSGi framework, it follows the
OSGi specifications without any changes to remain it in the installed state.
In this way, it is important to note that the DSP Platform and its
plug-and-play components are directly mapped with the OSGi Framework as
follows:

\begin{itemize}
  \item \textbf{OSGi Bundle} = DSP Component Artifact in Jar format
  \begin{itemize}
    \item SondeDSPProducer.jar is the component developed for the YSI sonde
  \end{itemize}  
  \item \textbf{OSGi Activator} = DSP Component Activator
  \begin{itemize}
    \item Class specified in the MANIFEST.MF artifact (next sections)
  \end{itemize} 
  \item \textbf{OSGi Service Reference} = DSP Component Class
  \begin{itemize}
    \item  Class specified by the component author.
  \end{itemize}
\end{itemize}

The DSP Platform, along with the DSP Framework, are the only DSP Components
needed to be installed into the OSGi container. For this reason,the DSP
Platform is responsible to install and activate the additional DSP components
that makes part of the platform during the start up process, which leverages
its bootstrap process. Nevertheless, in order to automate the process of
automatic install and removal of the plug-and-play components, the DSP Platform
provides a deployment configuration file that describes which DSP components
must be installed with a given priority number. The name of this configuration
artifact is called config.xml (see listing \ref{file:dsp-config.xml}), and is
depicted by the XML Schema \cite{xml-schema} in figure
\ref{fig:dsp-config-schema}.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.8]{../diagrams/config-schema}
  \caption{XML Schema for the main DSP deployment configuration artifact}
  \label{fig:dsp-config-schema}
\end{figure}

In order to show an example, consider the DSP Platform on the embedded system
Gumstix in figure \ref{fig:sf-netbeams-node}. It is started by providing a
deployment configuration artifact config.xml included in the appendix. It lists
the components that the DSP Platform needs to install and load for its
operation. As it is shown, the DSPWireTransportClient and the DSPSondeProducer
are the identification of the components, followed by the name of the physical
file and an assigned loading priority. While the DSPWireTransportClient is
responsible for the serialization and deserialization of the DSP Messages
exchanged by the DSPSondeProducer and any remote DSP component. In this case,
the DSPSondeProducer is the DSP component responsible to collect measurement
data from the YSI Sonde and temporarily store them before being transmitted.

Therefore, in order to orchestrate the DSP Components together, the DSP
Platform component is responsible for installing and uninstalling during its
state "Starting" and "Stopping", respectively, as it is shown in figure
\ref{fig:DSPPlatform-Install-Usage-State-Diagram}. When the system
administrator starts the DSP Platform, it performs the regular OSGi procedures
to start the bundle. Up until that state, it will get the list of DSP
Components to be installed as described in the config.xml artifact, trying to
install each of them in an optimistic way. After that, it will continue on the
state "Active" until the system administrator decides to stop it.

\begin{figure}[!b]
  \centering
  \includegraphics[scale=0.6]{../diagrams/DSPPlatform-Install-Usage-State-Diagram}
  \caption{The DSP Platform State Diagram}
  \label{fig:DSPPlatform-Install-Usage-State-Diagram}
\end{figure}

When the DSP Platform is on the Active state, it is ready to manage the DSP
Messages exchanges as described through figure
\ref{fig:DSP-Producers-Consumers-Components-Interactions}. The following
sections describe the participating classes in starting the DSP Platform and
its execution.

In a nutshell, the DSP Platform is an extension of the OSGi Platform, as it can
be seen in the UML Class Diagram \cite{uml} in figure
\ref{fig:DSP-Platform-Class-Diagram-Simple}. The class Activator contains a
unique instance of the Platform class, which contains instances of the classes
ComponentManager, Matcher, the MessageBroker and DSPContextImpl. The
DSPBundleController is the main instance that manages the plug-and-play DSP
components, and therefore, is tightly-coupled with the OSGi Framework classes.
Additionally, this class is part of the publish-subscriber design-pattern, as
it it implements the interfaces Bundle Listener and Service Listener, whose
responsibility is to track listens to the changes of the state of
ServicesReferences on the DSP Platform.

\begin{figure}[!t]
  \centering
  \includegraphics[scale=0.7]{../diagrams/DSP-Platform-Class-Diagram-Simple}
  \caption{The DSP Platform UML Class Diagram}
  \label{fig:DSP-Platform-Class-Diagram-Simple}
\end{figure}

\section{DSP Message and DSP Messages Container}
\label{sec:dsp-message}

As shown in the previous section, a DSP Message is the main unit of
communication among DSP Components. In a nutshell, a DSP Message can be seen
as an abstraction of an envelop containing the sections: a header and a body.
The former is used for identification and routing purposes, while the latter is
used to carry the payload of the message, that is, the collected data from
a sensor. Figure \ref{fig:DSP-Message-Representation} depicts the abstraction
of a DSP Message and its main components.

\begin{figure}[!b]
  \centering
  \includegraphics[scale=0.8]{../diagrams/DSP-Message-Representation}
  \caption{An Abstraction of a DSP Message and its components}
  \label{fig:DSP-Message-Representation}
\end{figure}

\begin{itemize}
  \item \textbf{Header} is composed by 2 blocks that identify the data
  producer and consumer of the message, as well as the time of creation, UUID,
  etc. It is an important piece of information for the data delivery and
  routing purposes.
  \item \textbf{Body} contains the payload of the message. This section carries
  the collected data from a sensor.
\end{itemize}

In general, the DSP Platform offers a veriety of types of DSP Messages for
different purposes. For example, any measurement data must be
wrapped up in a Measurement Message, while a Query Message is used to exchange
messages among the components for the purpose of management. In this way, the
main DSP Messages can be summarized as follows:

\begin{itemize}
  \item \textbf{Measurement Message} is used to transport any sensor collected
  data;
  \item \textbf{Query Message} is used to query a DSP component about its
  configuration properties;
  \item \textbf{Update Message} used to update a DSP component's configuration
  properties;
  \item \textbf{Acknowledgement Message} is used for the transport communication
  protocol, by acknowledging the reception of a DSP Message. More details in the
  Remote Data delivery section.
\end{itemize}

These DSP Classes and other can be seen in figure the  UML Class
Diagram \cite{uml} of figure \ref{fig:DSP-Messages-Classes}. Each DSP Message
contains an instance of a Header and Body. Whenever a DSP component is ready
to transmit messages, it wraps up the set of DSP Messages into the instance of
the Messages Container, which contains information about the collection of
messages being transmitted with its own identification. In this fashion, the
Messages Container is the main communication unit between 2 different DSP
Components.

\begin{figure}[!t]
  \centering
  \includegraphics[scale=0.6]{../diagrams/DSP-Messages-Classes}
  \caption{The DSP Messages UML Class Diagram}
  \label{fig:DSP-Messages-Classes}
\end{figure}

Another use of the DSP Messages is during the DSP Platform activation process,
where bootstrap messages are used to configure each DSP component. In order to
send configuration parameters, the DSP Platform uses Update Messages using a
unique type of Message Content called DSP Properties, which is described in the
next section.

\section{Collected Sensor Data as the DSP Message Content}

As mentioned in the previsou section, a DSP Message can carry any data on its
body, also called the payload. In such a way, any data representation must
just extend from the Message Content abstract class as it is shown
\ref{fig:Sonde-MessageContainer-Class-Diagram}, as defines the data
representation of the YSI Sonde data.

\begin{figure}[!h]
  \centering
  \includegraphics[scale=0.6]{../diagrams/Sonde-MessageContainer-Class-Diagram}
  \caption{The YSI Payload - Message Content UML Class Diagram}
  \label{fig:Sonde-MessageContainer-Class-Diagram}
\end{figure}

The properties measured from the YSI Sonde can be captured by the class
SondeDataType as a direct render of the measurements data depicted in table
\ref{tab:ysi-data-stream}. In addition to the regular data types, the class
also provides additional properties such as the attribute "samplingTimeStamp"
that carries the time when the data was collected from the YSI Sonde. However,
in order to capture a set of measurements at once, the SondeDataContainer
class used to carry a set of SondeDataType classes, as it is composed by one
or more instances of SondeDataType. In order to illustrate other examples,
consider the UML Class Diagram \cite{uml} of image
\ref{fig:Mouse-Actions--MessageContainer-Class-Diagram} as a payload of
observations made from a mouse over a screen, which captures the name of the
event, the button name and the x/y coordinates.

\begin{figure}[!h]
  \centering
  \includegraphics[scale=0.5]{../diagrams/Mouse-Actions--MessageContainer-Class-Diagram}
  \caption{The Mouse Actions Payload - Message Content UML Class Diagram}
  \label{fig:Mouse-Actions--MessageContainer-Class-Diagram}
\end{figure}

As described in the previous section, the DSP Platform uses DSP Update
Messages to configure internal components' initial configuration values. In
order to do so, the DSP Platform uses an instance of the DSP Properties, which
is composed of a list of initial DSP Property and their relating Values
instance depicted on the UML class diagram \cite{uml} of figure
\ref{fig:DSP-Property-Class-Diagram}. 

\begin{itemize}
  \item \textbf{Property Instance}: initial-rate
  \item \textbf{Value Instance}: 40
\end{itemize}

\begin{figure}[!t]
  \centering
  \includegraphics[scale=0.6]{../diagrams/DSP-Property-Class-Diagram}
  \caption{The DSP Property Payload - Message Content UML Class Diagram}
  \label{fig:DSP-Property-Class-Diagram}
\end{figure}

\subsection{DSP Platform Initialization Process}

All in all, the DSP Platform requires the knowledge of the aforementioned DSP
classes in order to initialize. The UML Sequence Diagram \cite{uml} in figure
\ref{fig:From-OSGi-DSP-Platform-Start-to-All-Components-Sequence-Diagram}
depicts the exact moments when the additional the plug-and-play DSP components
are installed and bootstrapped by the DSP Platform, as the UML State Diagram
\cite{uml} in figure \ref{fig:DSPPlatform-Install-Usage-State-Diagram}
described.

\begin{itemize}
  \item \textbf{Start DSP Activator Gate}: after installing the Activator
  indicated by the DSP Bundle's MANIFEST.MF artifact, the OSGi Framework makes
  a call to the method Activator.start();
  \item \textbf{Bootstrap DSP Component Gate}: after the component has been
  initialized (by the call the method init() from the class ComponentManager),
  the DSP Component is ready to be bootstrapped, and the optional bootstrap
  message is delivered.
\end{itemize}

\begin{figure}[!b]
  \centering
  \includegraphics[scale=0.5]{../diagrams/From-OSGi-DSP-Platform-Start-to-All-Components-Sequence-Diagram}
  \caption{The DSP Platform Initialization UML Sequence Diagram}
  \label{fig:From-OSGi-DSP-Platform-Start-to-All-Components-Sequence-Diagram}
\end{figure}

\newpage

\subsection{Data Delivery Mechanism}

In general, when a DSP Component finishes preparing the DSP Messages Container,
it contacts an entity responsible for sending and proxying message to other
components. The DSP Broker acts like a mailman, receiving messages and
forwarding copies of it to other entities in the system, abstraction in which
is shown in figure \ref{fig:DSP-Message-Broker-Abstraction}. In this way, the
DSP Broker receives a DSP Message and makes necessary deliveries to DSP
components that it has knowledge of.

\begin{figure}[!h]
  \centering
  \includegraphics[scale=0.8]{../diagrams/DSP-Message-Broker-Abstraction}
  \caption{A DSP Message Broker Abstraction}
  \label{fig:DSP-Message-Broker-Abstraction}
\end{figure}

The use of messaging exchange paradigm is used in NetBEAMS because it decouples
the system by using messages take into account their structure to filter the
messages. In this way, the DSP Broker uses a filter component called DSP
Matcher, which provides a list of DSP Components that needs to receive a copy
of the DSP Message. It turns out that the DSP Matcher bases its decisions on
structured rules provided by the system administrator for an specific DSP
Platform instance. The UML Class diagram for the DSP Broker, Matcher and
particiaping classes is depicted in figure
\ref{fig:DSPBroker-Matcher-Class-Diagram}, and describes how the DSP Broker
implementation is tightly coupled with the DSP Matcher, as well as to the
lists of DSP Components sorted by name and type.

\begin{figure}[!b]
  \centering
  \includegraphics[scale=0.6]{../diagrams/DSPBroker-Matcher-Class-Diagram}
  \caption{The DSP Broker-Matcher UML Class Diagram}
  \label{fig:DSPBroker-Matcher-Class-Diagram}
\end{figure}

In general, the DSP Matcher is composed by a list of MatchRule, which contains
a reference to a MatchCriteria and a MatchTarget. The former identifies the
rule for matching a given DSP Message based on the producer and consumer's
message type and location, while the latter describes the DSP Component that
will receive the DSP Message, and if its delivery is done by means of a gateway
component. In this way, the DSP Matcher can be seen as a function that takes a
DSP Message as an input and returns a list of DSP consumers, and the
matching configuration artifact provided by the administrator. See listing
\ref{file:dsp-matcher-config.xml}) for details.

\begin{table}
    \caption{DSP Matcher Rule Algorithm to filter Data Consumer components to
    receive a given Message}
    \begin{center}
        \begin{tabular}{lr}
          \textit{Data Consumers ( DSP Message )} := \\ 
          Verify the DSP Message's Header + \\
          Verify the matcher rules, which contains the list of consumers for
          the given message
        \end{tabular}
    \end{center}
    \label{tab:ysi-data-stream}
\end{table}

One example of such matching rule used by the DSP installed at the Gumstix can
be seen in listing \ref{file:dsp-matcher-config-gumstix.xml}. the Gumstix
system to configure the data delivery of the messages produced by the DSP
Component DSP Sonde Producer. It describes a list of maching rules that
reseambles a filtering system. This configuration contains 2 match rules: one
related to internal DSP Configuration and another for a remote destination.
The match criteria describes what the DSP Message Header properties must be,
while the match target is the destination of the message. One important
definition is the gateway Component Type, which defines the name of a remote
DSP Component that is capable of receiving a remote DSP Message.

Upon receiving all the matching rules and analyzing the DSP Message against
the rules, the DSP Broker selects a set of the running DSP components to receive
a copy of the DSP Message object in two different ways:

\begin{itemize}
  \item \textbf{In-memory local message delivery}: if the receiving DSP
  Component is located in the current local host, a deep copy of the instance
  of the DSP message is delivered;
    \begin{itemize}[label=\textbullet]
        \item IP Addresses are correctly resolved by using the Ethernet card in
        the device: localhost, 127.0.0.1, or the same IP Address for Producer
        and Receiver resolves into a local device. An example for such type of
        delivery can be seen in the match ruleID
        all messages sent to dsp manager of listing 
        \ref{file:dsp-matcher-config-gumstix.xml}.
    \end{itemize}
  \item \textbf{Serialized remote message delivery}: if the receiving DSP
  Component is located in a foreign/remote host, the message is serialized in a
  format defined by the transport protocol chosen the DSP Component responsible
  for the transport. The following section describes the existing DSP Data
  Transport component;     
  \begin{itemize}[label=\textbullet]
        \item IP Address from the Producer and Consumer are different, and are
        not resolved to be in the same host. An instance of such match rule can
        be seen in the match rule ID send-message-to-remote url dsp of the code
        snippet \ref{file:dsp-matcher-config-gumstix.xml}.
    \end{itemize}
\end{itemize}

\subsection{Sending DSP Messages through the Wire}

In order to send messages through the wire, the DSP Platform uses two symmetric
components that serialize and deserialize DSP Messages to XML and back to Java
POJO, respectively, and vice-versa. Named DSP Wire Transport Client and DSP
Wire Transport Server \cite{netbeams2009}, these components use the HTTP
\cite{http} protocol to transport the serialized version of the DSP Messages.
Figure \ref{fig:DSP-to-DSP-Remote-Communication} depicts the scenario where a
DSP Sensor Node transmits a DSP Message through an HTTP POST request.

\begin{figure}[!b]
  \centering
  \includegraphics[scale=0.6]{../diagrams/DSP-to-DSP-Remote-Communication}
  \caption{The remote communication between two DSP Components using the HTTP
  Protocol}
  \label{fig:DSP-to-DSP-Remote-Communication}
\end{figure}

\begin{itemize}
  \item \textbf{DSP Wire Transport Client}: responsible for making HTTP POST
  Requests to the service provided by the DSP Wire Transport Server component.
  The body of the HTTP POST request contains a serialized version of an
  instance of a DSP MessagesContainer in XML format;
  \item \textbf{DSP Wire Transport Server}: exposes a Web Server listening to
  port 8080 that receives the HTTP POST request from the Client. Upon receiving
  the request, the server deserializes the DSP MessagesContainer back to the
  in-memory POJO and proceeds with the delivery to the DSP Broker. At this
  situation, the component packages acknowledgement messages and any queued
  message to the client and piggybacks \cite{xml-piggybacking} it to the HTTP
  response body.
\end{itemize}

As described by \cite{netbeams2009}, NetBEAMS is a single-hop sensor network
whose sensors transmits data from the sensors to the server. Upon receiving the
data stream, the DSP Wire Transport Server component desirializes the DSP
MessagesContainer and its enclosing DSP Messages back to a Java class instance
and delivers each of the DSP Messages to the DSP Broker, which delivers a
copy of the message to each DSP Component listed by the maching rule. 
%This
%process is depicted by the UML Sequence Diagram \cite{uml} in figure \ref{fig:}

Whenever a DSP bundle producer is ready to transmit messages, they are added
into a DSP Messages Container (see UML Class Diagram in figure
\ref{fig:DSP-Messages-Classes}), which is serialized in XML to be transmitted.
Listing \ref{file:dsp-message-serialized-ysi} shows an instance of a DSP
MessagesContainer in serialized in XML, ready for transmission. In fact, the
listing is an example of the transmitted data collected from a sensor located
at the 192.168.0.103 to be transmitted to the host 192.168.0.106, and the
process of transmission in the server-side can be followed in figure
\ref{fig:From-DSPSondeComponent-to-DSPWireTransportClient-Sequence}.

\begin{figure}[!h]
  \centering
  \includegraphics[scale=0.5]{../diagrams/From-DSPSondeComponent-to-DSPWireTransportClient-Sequence}
  \caption{The UML Sequence Diagram for the production of a YSI Message}
  \label{fig:From-DSPSondeComponent-to-DSPWireTransportClient-Sequence}
\end{figure}

The Sonde DSP Component is responsible for starting a worker thread called
SondeProducer, which is responsible for constantly read from the RS-232 serial
port by using an instance of the SerialReader class. This process depicts the
production of the data flow "flow 1" of figure
\ref{fig:netbeams-software-stack}, which is a collection of SondeDataType for
each of the measurement data read on a SondeDataContainer. As depicted in
figure \ref{fig:From-DSPSondeComponent-to-DSPWireTransportClient-Sequence}, it
first read the serial connection using the class SerialReader, which parses 
the data stream. After parsing the data, the reader creates an instance of the
class SondeDataType, the POJO responsible for carrying out the measurement
data. As described earlier, the data is added into the SondeDataContainer to
dispatched to the DSP Broker, whose responsibility is to get the list of DSP
Components that is setup to receive a copy of the DSP message (see previous
code snippet). As for the setup done for the Gumstix, the measurement message
is supposed to be sent to a remote destination of host 192.168.0.7. At this
point, the DSP Broker makes a decision to send the DSP Message to the default
gateway component DSPWireTransportClient.

After the message arrives in the DSPWireTransportClient, the message is
maintained in a temporary repository of outbound DSP Messages called
MessagesQueues after the message is hashed by the destination IP address and
the DSP Client sender using an instance of QueueMessageData. As shown in figure
\ref{fig:From-DSPWireTransport-Client-to-DSPWireTransportServer-Sequence}, the
DSP TransportSender is a worker thread that is started by the DSP Wire
Transport Client and is constantly transmits the data in the outbound queues
after a configurable rate. It makes a transport of the message and receives
the response, updates the state of the messages to transmitted, to finally
send the response messages to the DSP Message Broker.

\begin{figure}[!t]
  \centering
  \includegraphics[scale=0.5]{../diagrams/From-DSPWireTransport-Client-to-DSPWireTransportServer-Sequence}
  \caption{The UML Sequence Diagram describing the Wire Transport Server
  receiving a DSP Message}
  \label{fig:From-DSPWireTransport-Client-to-DSPWireTransportServer-Sequence}
\end{figure}

While the DSPWireTransportClient makes an HTTP Request with the DSP Message,
the DSPWireTransportServer's servlet receives the request. It first
deserializes the MessagesContainer and delivers each of its messages to the DSP
Broker. At this point, the server verifies if there are messages in the
outbound queue that are addressed for the host that requested the messages
delivery. By using a technique called piggybacking, the server adds to the HTTP
Response a serialized version of the MessagesContainer with any DSP Messages.
In addition to any DSP Message, the server prepares and sends acknowledgement
messages back to the requesting host to the host.

\begin{figure}[!t]
  \centering
  \includegraphics[scale=0.5]{../diagrams/From-DSPWireTransport-Server-To-DSP-Broker}
  \caption{The UML Sequence diagram describing the DSP
Message delivery on the server-side and the response}
  \label{fig:From-DSPWireTransport-Server-To-DSP-Broker}
\end{figure}

The gate "From DSP WireTransport Server to Broker Gate" defines the actual
delivery of the DSP Message to the DSP Broker. As this section is a tutorial
about the DSP Platform, the remaining steps will be explained on Section 3,
while showing the design and implementation of the component DSP Data
Persistence.

\section{Source-Code and Implemented Artifacts}

\lstinputlisting[language=Ant,label=file:dsp-build.xml,caption=Build
system using Apache ANT]{../../../../netbeams/versions/v2/apps/osgi-bundles/dsp/DSPDataPersistence/build.xml}

\lstinputlisting[label=file:osgi-manifest,caption=OSGi Manifest
Descriptor]{../../../../netbeams/versions/v2/apps/osgi-bundles/dsp/DSPDataPersistence/META-INF/MANIFEST.MF}

\lstinputlisting[language=XML,label=file:dsp-config.xml,caption=DSP
Deployment
Configuration]{../../../../netbeams/versions/v2/config/deployment/config.xml}

\lstinputlisting[language=XML,label=file:dsp-matcher-config.xml,caption=DSP
Matching Rules]{../../../../netbeams/versions/v2/config/deployment/matcher_config.xml}

\lstinputlisting[language=XML,label=file:dsp-matcher-config-gumstix.xml,caption=DSP
Matching Rules
for
Gumstix]{../../../../netbeams/versions/v2/config/deployment/matcher_config-gumstix.xml}

\lstinputlisting[language=XML,label=file:dsp-data-persistence-bootstrap.xml,caption=DSP
Message used to bootstrap the DSP Data Persistence Component]
{../../../../netbeams/versions/v2/apps/xml/samples/DSPDataPersistence_001.xml}

%TODO: add bootstrap message in case it is implemented

\lstinputlisting[language=Java,label=file:dsp-activator,caption=OSGi
Activator]{../../../../netbeams/versions/v2/apps/osgi-bundles/dsp/DSPDataPersistence/src/org/netbeams/dsp/persistence/osgi/DataPersistenceActivator.java}

\lstinputlisting[language=Java,label=file:dsp-component-service,caption=OSGi
Service - Component]{../../../../netbeams/versions/v2/apps/osgi-bundles/dsp/DSPDataPersistence/src/org/netbeams/dsp/persistence/controller/DSPDataPersistence.java}

\lstinputlisting[language=Java,label=file:dsp-mongo-service,caption=DSP Data to
Mongo DB
Service]{../../../../netbeams/versions/v2/apps/osgi-bundles/dsp/DSPDataPersistence/src/org/netbeams/dsp/persistence/controller/DSPMongoCRUDService.java}

\lstset{language=XML,morecomment=[s]{!--}{--},label=file:dsp-message-serialized-ysi,caption=DSP
Message with a YSI sonde data payload}
\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<MessagesContainer uudi="24929c29-60ee-4d17-af08-64d9446277ef"
        creationTime="2009-03-06T15:17:18-0800" destinationHost="192.168.0.106">
   <MeasureMessage ContentType="org.netbeams.dsp.ysi"
         messageID="435a61f6-370f-458d-aeb7-6e92270a79cb">
      <Header>
         <CreationTime>1236381438480</CreationTime>
         
         <Producer>   
            <ComponentType>
                 org.netbeams.dsp.platform.management.component.ComponentManager
            </ComponentType>
            
            <ComponentLocator>
               <ComponentNodeId>1234</ComponentNodeId>
               <NodeAddress>192.168.0.103</NodeAddress>
            </ComponentLocator>
         </Producer>
         
         <Consumer>
            <ComponentType>
                 org.netbeams.dsp.wiretransport.client
            </ComponentType>
            
            <ComponentLocator>
               <NodeAddress>LOCAL</NodeAddress>
            </ComponentLocator>
         </Consumer>
      </Header>
      <Body>
         <SondeDataContainer>
            <soundeData date="15:17:18" time="03-06-2009">  
               <Temp>21.20</Temp>
               <SpCond>193</SpCond>
               <Cond>179</Cond>
               <Resist>5588.40</Resist>
               <Sal>0.09</Sal>
               <Press>0.084</Press>
               <Depth>0.059</Depth>
               <pH>7.98</pH>
               <phmV>-79.6</phmV>
               <ODOSat>99.5</ODOSat>
               <ODOConc>8.83</ODOConc>
               <Turbid>0.4</Turbid>
               <Battery>8.7</Battery>
            </soundeData>
         </SondeDataContainer>
      </Body>
   </MeasureMessage>
</MessagesContainer>
\end{lstlisting}

\section{Experiment Implementation}

\lstinputlisting[language=Bash,label=file:experiment-setup-executor,caption=Experiment
Implementation]{../../../../netbeams/versions/v2/persistence/run-persistence-experiment}

\lstinputlisting[language=Java,label=file:experiment-dsp-implementation,caption=Experiment
Implementation]{../../../../netbeams/versions/v2/apps/osgi-bundles/dsp/DSPDataPersistence/src/org/netbeams/dsp/persistence/controller/DSPMessageToMongoDBExperiment.java}

\lstset{label=file:mongodb-ysi-data-format,caption=JSON representation of the
data produced by a YSI sensor on mongoDB}
\begin{lstlisting}
            {
             "_id" :  ObjectId( "d36f4007b7e7ac4a03c60000")  , 
             "sensor_ip_address" : "192.168.0.136", 
             "message_id" : "7b6624d6-0ca1-4cba-a343-f166e88da73b",
             "transaction_time" : 1252845473412 , 
             "fact_time" : 1252845346000,
             "latitude" : 12.3450, 
             "longitude" : -123.4456 , 
             "data" : {
                       "temperature" : 45.01, 
                       "sp_condition" : 37.6, 
                       "condition" : 145.8, 
                       "resistence" : 159.77, 
                       "salinitude" : 0.0, 
                       "pressure" : 0.391, 
                       "depth" : 0.46, 
                       "ph" : 5.64, 
                       "pH_mv" : -62.1, 
                       "odo_sat" : 89.7, 
                       "odo_condition" : 59.34, 
                       "turbidity" : 0.0,
                       "battery" : 9.4
                      }
            }
\end{lstlisting}

\lstset{label=file:rtc-ysi-opendap,caption=HTTP GET Request x Response to the OPeNDAP server at SF-BEAMS}
\begin{lstlisting}
http://sfbeams.sfsu.edu:8080/opendap/sfbeams/data_ctd/rtc_ctd5-ysimoor/real-time/sfb_CTD5_PUF.dat.ascii?
GET /opendap/sfbeams/data_ctd/rtc_ctd5-ysimoor/real-time/sfb_CTD5_PUF.dat.dods?&Month=11&Day=12 HTTP/1.1

HTTP/1.x 200 OK
Server: Apache-Coyote/1.1
Last-Modified: Thu, 12 Nov 2009 17:55:06 GMT
XDODS-Server: Server-Version-Unknown
XOPeNDAP-Server: bes/3.5.1 freeform_handler/3.7.5, netcdf_handler/3.7.6
XDAP: 3.2
Content-Description: dods_data
Content-Type: text/txt
Date: Sun, 15 Nov 2009 03:08:45 GMT

Dataset: sfb_CTD5_PUF.dat
YSI_REALTIME_CSV.Month, YSI_REALTIME_CSV.Day, YSI_REALTIME_CSV.Year, YSI_REALTIME_CSV.Hour, YSI_REALTIME_CSV.Min, YSI_REALTIME_CSV.Sec, YSI_REALTIME_CSV.WaterTemperature, YSI_REALTIME_CSV.SpecificConductivity, YSI_REALTIME_CSV.Conductivity, YSI_REALTIME_CSV.Resistivity, YSI_REALTIME_CSV.TDS, YSI_REALTIME_CSV.Salinity, YSI_REALTIME_CSV.Pressure, YSI_REALTIME_CSV.Depth, YSI_REALTIME_CSV.pH, YSI_REALTIME_CSV.pHmV, YSI_REALTIME_CSV.Turbidity, YSI_REALTIME_CSV.ODOSaturation, YSI_REALTIME_CSV.ODO, YSI_REALTIME_CSV.Chlor, YSI_REALTIME_CSV.Chlor_RFU, YSI_REALTIME_CSV.Battery, YSI_REALTIME_CSV.InstSN
11, 12, 2009, 16, 30, 51, 13.78, 4.3945, 3.4532, 0, 28.56, 28.35, 2.65, 2.651, 7.9, -54.7, 9, -99999, -99999, 3.7, 1, 9.4, -99999
11, 12, 2009, 16, 36, 50, 13.78, 4.4095, 3.4642, 0, 28.66, 28.46, 2.628, 2.63, 7.91, -54.9, 11.9, -99999, -99999, 4, 1.1, 9.4, -99999
11, 12, 2009, 16, 42, 51, 13.77, 4.3943, 3.4515, 0, 28.56, 28.35, 2.631, 2.632, 7.9, -54.9, 9.8, -99999, -99999, 3.6, 1, 9.4, -99999
11, 12, 2009, 16, 48, 50, 13.76, 4.3893, 3.447, 0, 28.53, 28.32, 2.628, 2.63, 7.9, -54.8, 10.6, -99999, -99999, 3.8, 1, 9.4, -99999
\end{lstlisting}

